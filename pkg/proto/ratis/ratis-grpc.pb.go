// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ratis-grpc.proto

package ratis

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used. Bla.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClientProtocolServiceClient is the client API for RaftClientProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClientProtocolServiceClient interface {
	// A client-to-server RPC to set new raft configuration
	SetConfiguration(ctx context.Context, in *SetConfigurationRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error)
	// A client-to-server stream RPC to ordered async requests
	Ordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_OrderedClient, error)
	// A client-to-server stream RPC for unordered async requests
	Unordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_UnorderedClient, error)
}

type raftClientProtocolServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftClientProtocolServiceClient(cc *grpc.ClientConn) RaftClientProtocolServiceClient {
	return &raftClientProtocolServiceClient{cc}
}

func (c *raftClientProtocolServiceClient) SetConfiguration(ctx context.Context, in *SetConfigurationRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error) {
	out := new(RaftClientReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.RaftClientProtocolService/setConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClientProtocolServiceClient) Ordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_OrderedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftClientProtocolService_serviceDesc.Streams[0], "/ratis.grpc.RaftClientProtocolService/ordered", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftClientProtocolServiceOrderedClient{stream}
	return x, nil
}

type RaftClientProtocolService_OrderedClient interface {
	Send(*RaftClientRequestProto) error
	Recv() (*RaftClientReplyProto, error)
	grpc.ClientStream
}

type raftClientProtocolServiceOrderedClient struct {
	grpc.ClientStream
}

func (x *raftClientProtocolServiceOrderedClient) Send(m *RaftClientRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftClientProtocolServiceOrderedClient) Recv() (*RaftClientReplyProto, error) {
	m := new(RaftClientReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClientProtocolServiceClient) Unordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_UnorderedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftClientProtocolService_serviceDesc.Streams[1], "/ratis.grpc.RaftClientProtocolService/unordered", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftClientProtocolServiceUnorderedClient{stream}
	return x, nil
}

type RaftClientProtocolService_UnorderedClient interface {
	Send(*RaftClientRequestProto) error
	Recv() (*RaftClientReplyProto, error)
	grpc.ClientStream
}

type raftClientProtocolServiceUnorderedClient struct {
	grpc.ClientStream
}

func (x *raftClientProtocolServiceUnorderedClient) Send(m *RaftClientRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftClientProtocolServiceUnorderedClient) Recv() (*RaftClientReplyProto, error) {
	m := new(RaftClientReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftClientProtocolServiceServer is the server API for RaftClientProtocolService service.
type RaftClientProtocolServiceServer interface {
	// A client-to-server RPC to set new raft configuration
	SetConfiguration(context.Context, *SetConfigurationRequestProto) (*RaftClientReplyProto, error)
	// A client-to-server stream RPC to ordered async requests
	Ordered(RaftClientProtocolService_OrderedServer) error
	// A client-to-server stream RPC for unordered async requests
	Unordered(RaftClientProtocolService_UnorderedServer) error
}

func RegisterRaftClientProtocolServiceServer(s *grpc.Server, srv RaftClientProtocolServiceServer) {
	s.RegisterService(&_RaftClientProtocolService_serviceDesc, srv)
}

func _RaftClientProtocolService_SetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConfigurationRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClientProtocolServiceServer).SetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.RaftClientProtocolService/SetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClientProtocolServiceServer).SetConfiguration(ctx, req.(*SetConfigurationRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftClientProtocolService_Ordered_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftClientProtocolServiceServer).Ordered(&raftClientProtocolServiceOrderedServer{stream})
}

type RaftClientProtocolService_OrderedServer interface {
	Send(*RaftClientReplyProto) error
	Recv() (*RaftClientRequestProto, error)
	grpc.ServerStream
}

type raftClientProtocolServiceOrderedServer struct {
	grpc.ServerStream
}

func (x *raftClientProtocolServiceOrderedServer) Send(m *RaftClientReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftClientProtocolServiceOrderedServer) Recv() (*RaftClientRequestProto, error) {
	m := new(RaftClientRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftClientProtocolService_Unordered_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftClientProtocolServiceServer).Unordered(&raftClientProtocolServiceUnorderedServer{stream})
}

type RaftClientProtocolService_UnorderedServer interface {
	Send(*RaftClientReplyProto) error
	Recv() (*RaftClientRequestProto, error)
	grpc.ServerStream
}

type raftClientProtocolServiceUnorderedServer struct {
	grpc.ServerStream
}

func (x *raftClientProtocolServiceUnorderedServer) Send(m *RaftClientReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftClientProtocolServiceUnorderedServer) Recv() (*RaftClientRequestProto, error) {
	m := new(RaftClientRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftClientProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.RaftClientProtocolService",
	HandlerType: (*RaftClientProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setConfiguration",
			Handler:    _RaftClientProtocolService_SetConfiguration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ordered",
			Handler:       _RaftClientProtocolService_Ordered_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "unordered",
			Handler:       _RaftClientProtocolService_Unordered_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "ratis-grpc.proto",
}

// RaftServerProtocolServiceClient is the client API for RaftServerProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftServerProtocolServiceClient interface {
	RequestVote(ctx context.Context, in *RequestVoteRequestProto, opts ...grpc.CallOption) (*RequestVoteReplyProto, error)
	AppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_AppendEntriesClient, error)
	InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_InstallSnapshotClient, error)
}

type raftServerProtocolServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftServerProtocolServiceClient(cc *grpc.ClientConn) RaftServerProtocolServiceClient {
	return &raftServerProtocolServiceClient{cc}
}

func (c *raftServerProtocolServiceClient) RequestVote(ctx context.Context, in *RequestVoteRequestProto, opts ...grpc.CallOption) (*RequestVoteReplyProto, error) {
	out := new(RequestVoteReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.RaftServerProtocolService/requestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServerProtocolServiceClient) AppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_AppendEntriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftServerProtocolService_serviceDesc.Streams[0], "/ratis.grpc.RaftServerProtocolService/appendEntries", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftServerProtocolServiceAppendEntriesClient{stream}
	return x, nil
}

type RaftServerProtocolService_AppendEntriesClient interface {
	Send(*AppendEntriesRequestProto) error
	Recv() (*AppendEntriesReplyProto, error)
	grpc.ClientStream
}

type raftServerProtocolServiceAppendEntriesClient struct {
	grpc.ClientStream
}

func (x *raftServerProtocolServiceAppendEntriesClient) Send(m *AppendEntriesRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftServerProtocolServiceAppendEntriesClient) Recv() (*AppendEntriesReplyProto, error) {
	m := new(AppendEntriesReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftServerProtocolServiceClient) InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_InstallSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftServerProtocolService_serviceDesc.Streams[1], "/ratis.grpc.RaftServerProtocolService/installSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftServerProtocolServiceInstallSnapshotClient{stream}
	return x, nil
}

type RaftServerProtocolService_InstallSnapshotClient interface {
	Send(*InstallSnapshotRequestProto) error
	CloseAndRecv() (*InstallSnapshotReplyProto, error)
	grpc.ClientStream
}

type raftServerProtocolServiceInstallSnapshotClient struct {
	grpc.ClientStream
}

func (x *raftServerProtocolServiceInstallSnapshotClient) Send(m *InstallSnapshotRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftServerProtocolServiceInstallSnapshotClient) CloseAndRecv() (*InstallSnapshotReplyProto, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InstallSnapshotReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftServerProtocolServiceServer is the server API for RaftServerProtocolService service.
type RaftServerProtocolServiceServer interface {
	RequestVote(context.Context, *RequestVoteRequestProto) (*RequestVoteReplyProto, error)
	AppendEntries(RaftServerProtocolService_AppendEntriesServer) error
	InstallSnapshot(RaftServerProtocolService_InstallSnapshotServer) error
}

func RegisterRaftServerProtocolServiceServer(s *grpc.Server, srv RaftServerProtocolServiceServer) {
	s.RegisterService(&_RaftServerProtocolService_serviceDesc, srv)
}

func _RaftServerProtocolService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServerProtocolServiceServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.RaftServerProtocolService/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServerProtocolServiceServer).RequestVote(ctx, req.(*RequestVoteRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftServerProtocolService_AppendEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServerProtocolServiceServer).AppendEntries(&raftServerProtocolServiceAppendEntriesServer{stream})
}

type RaftServerProtocolService_AppendEntriesServer interface {
	Send(*AppendEntriesReplyProto) error
	Recv() (*AppendEntriesRequestProto, error)
	grpc.ServerStream
}

type raftServerProtocolServiceAppendEntriesServer struct {
	grpc.ServerStream
}

func (x *raftServerProtocolServiceAppendEntriesServer) Send(m *AppendEntriesReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftServerProtocolServiceAppendEntriesServer) Recv() (*AppendEntriesRequestProto, error) {
	m := new(AppendEntriesRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftServerProtocolService_InstallSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServerProtocolServiceServer).InstallSnapshot(&raftServerProtocolServiceInstallSnapshotServer{stream})
}

type RaftServerProtocolService_InstallSnapshotServer interface {
	SendAndClose(*InstallSnapshotReplyProto) error
	Recv() (*InstallSnapshotRequestProto, error)
	grpc.ServerStream
}

type raftServerProtocolServiceInstallSnapshotServer struct {
	grpc.ServerStream
}

func (x *raftServerProtocolServiceInstallSnapshotServer) SendAndClose(m *InstallSnapshotReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftServerProtocolServiceInstallSnapshotServer) Recv() (*InstallSnapshotRequestProto, error) {
	m := new(InstallSnapshotRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftServerProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.RaftServerProtocolService",
	HandlerType: (*RaftServerProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "requestVote",
			Handler:    _RaftServerProtocolService_RequestVote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "appendEntries",
			Handler:       _RaftServerProtocolService_AppendEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "installSnapshot",
			Handler:       _RaftServerProtocolService_InstallSnapshot_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "ratis-grpc.proto",
}

// AdminProtocolServiceClient is the client API for AdminProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminProtocolServiceClient interface {
	// A client-to-server RPC to add a new group
	GroupManagement(ctx context.Context, in *GroupManagementRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error)
	GroupList(ctx context.Context, in *GroupListRequestProto, opts ...grpc.CallOption) (*GroupListReplyProto, error)
	GroupInfo(ctx context.Context, in *GroupInfoRequestProto, opts ...grpc.CallOption) (*GroupInfoReplyProto, error)
}

type adminProtocolServiceClient struct {
	cc *grpc.ClientConn
}

func NewAdminProtocolServiceClient(cc *grpc.ClientConn) AdminProtocolServiceClient {
	return &adminProtocolServiceClient{cc}
}

func (c *adminProtocolServiceClient) GroupManagement(ctx context.Context, in *GroupManagementRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error) {
	out := new(RaftClientReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupManagement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminProtocolServiceClient) GroupList(ctx context.Context, in *GroupListRequestProto, opts ...grpc.CallOption) (*GroupListReplyProto, error) {
	out := new(GroupListReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminProtocolServiceClient) GroupInfo(ctx context.Context, in *GroupInfoRequestProto, opts ...grpc.CallOption) (*GroupInfoReplyProto, error) {
	out := new(GroupInfoReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminProtocolServiceServer is the server API for AdminProtocolService service.
type AdminProtocolServiceServer interface {
	// A client-to-server RPC to add a new group
	GroupManagement(context.Context, *GroupManagementRequestProto) (*RaftClientReplyProto, error)
	GroupList(context.Context, *GroupListRequestProto) (*GroupListReplyProto, error)
	GroupInfo(context.Context, *GroupInfoRequestProto) (*GroupInfoReplyProto, error)
}

func RegisterAdminProtocolServiceServer(s *grpc.Server, srv AdminProtocolServiceServer) {
	s.RegisterService(&_AdminProtocolService_serviceDesc, srv)
}

func _AdminProtocolService_GroupManagement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupManagementRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupManagement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupManagement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupManagement(ctx, req.(*GroupManagementRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminProtocolService_GroupList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupListRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupList(ctx, req.(*GroupListRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminProtocolService_GroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupInfoRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupInfo(ctx, req.(*GroupInfoRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdminProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.AdminProtocolService",
	HandlerType: (*AdminProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "groupManagement",
			Handler:    _AdminProtocolService_GroupManagement_Handler,
		},
		{
			MethodName: "groupList",
			Handler:    _AdminProtocolService_GroupList_Handler,
		},
		{
			MethodName: "groupInfo",
			Handler:    _AdminProtocolService_GroupInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ratis-grpc.proto",
}

func init() { proto.RegisterFile("ratis-grpc.proto", fileDescriptor_90b877a855096828) }

var fileDescriptor_90b877a855096828 = []byte{
	// 396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0xdf, 0x8a, 0xda, 0x40,
	0x18, 0xc5, 0x1b, 0x2f, 0x5a, 0x9c, 0x52, 0x94, 0xa1, 0x37, 0xb5, 0x57, 0xd5, 0x8a, 0xb6, 0x60,
	0x52, 0xec, 0x13, 0xa8, 0x14, 0x11, 0x5a, 0x28, 0x4a, 0x85, 0xd6, 0xab, 0x31, 0xf9, 0x12, 0x87,
	0x26, 0xf3, 0xcd, 0xce, 0x4c, 0x16, 0x76, 0x9f, 0x66, 0x2f, 0xf7, 0x15, 0xf6, 0x15, 0xf6, 0xa9,
	0x96, 0x4c, 0x04, 0x9d, 0xac, 0x7f, 0xd8, 0x85, 0xbd, 0xf4, 0x3b, 0xe7, 0xfc, 0x8e, 0x1c, 0x32,
	0xa4, 0xa9, 0x98, 0xe1, 0x7a, 0x90, 0x28, 0x19, 0xfa, 0x52, 0xa1, 0x41, 0x4a, 0xec, 0xc5, 0x2f,
	0x2e, 0x2d, 0xa2, 0x58, 0x6c, 0xca, 0xfb, 0xf0, 0xae, 0x46, 0x3e, 0xcc, 0x59, 0x6c, 0x26, 0x29,
	0x07, 0x61, 0x7e, 0x17, 0xb7, 0x10, 0xd3, 0x05, 0xa8, 0x4b, 0x1e, 0x02, 0x8d, 0x48, 0x53, 0x83,
	0x99, 0xa0, 0x88, 0x79, 0x92, 0x17, 0x04, 0x14, 0xf4, 0xab, 0x5f, 0xa2, 0x42, 0xcc, 0x32, 0x14,
	0xfe, 0xa2, 0xa2, 0xcf, 0xe1, 0x22, 0x07, 0x5d, 0x92, 0x5a, 0x6d, 0xd7, 0xbb, 0x2b, 0x9a, 0x83,
	0x4c, 0xaf, 0xac, 0xa7, 0xfd, 0x8a, 0xfe, 0x25, 0x6f, 0x50, 0x45, 0xa0, 0x20, 0xa2, 0x9f, 0x8f,
	0x07, 0x9e, 0x8a, 0xed, 0x7b, 0xdf, 0x3c, 0xba, 0x22, 0xf5, 0x5c, 0xbc, 0x10, 0x7c, 0x78, 0xbf,
	0xdd, 0xae, 0x58, 0x0b, 0x54, 0x75, 0xbb, 0x15, 0x79, 0xab, 0x4a, 0xee, 0x12, 0x0d, 0xd0, 0x6e,
	0x05, 0xbb, 0x93, 0x9c, 0xf6, 0xce, 0x09, 0xdb, 0xde, 0x64, 0x40, 0xde, 0x31, 0x29, 0x41, 0x44,
	0x3f, 0x84, 0x51, 0x1c, 0x34, 0xed, 0xb9, 0xb9, 0xd1, 0xbe, 0xe8, 0x14, 0x74, 0x4f, 0x1a, 0x2b,
	0xf3, 0x71, 0xd2, 0xe0, 0x42, 0x1b, 0x96, 0xa6, 0x0b, 0xc1, 0xa4, 0xde, 0xa0, 0xa1, 0x5f, 0xdc,
	0xfc, 0xcc, 0x95, 0x9d, 0xaa, 0xde, 0x19, 0xeb, 0x7e, 0xd9, 0xf0, 0xb6, 0x46, 0xde, 0x8f, 0xa2,
	0x8c, 0x8b, 0xea, 0x8e, 0x6b, 0xd2, 0x48, 0x14, 0xe6, 0xf2, 0x17, 0x13, 0x2c, 0x81, 0x0c, 0xc4,
	0xa3, 0xff, 0x30, 0x75, 0xe5, 0x67, 0x7c, 0x81, 0x7f, 0x48, 0xdd, 0x76, 0xfc, 0xe4, 0xda, 0xd0,
	0xce, 0x01, 0x7a, 0x21, 0x38, 0xdc, 0x4f, 0x47, 0x4d, 0x07, 0xb0, 0x33, 0x11, 0xe3, 0x41, 0x6c,
	0x21, 0x9c, 0xc5, 0x96, 0xa6, 0x1d, 0x76, 0xbc, 0x24, 0x1f, 0x51, 0x25, 0x3e, 0x93, 0x2c, 0xdc,
	0xc0, 0x36, 0x60, 0x5f, 0xb3, 0x7d, 0xde, 0x63, 0x32, 0x55, 0x32, 0xb4, 0x5e, 0xfd, 0xaf, 0x9f,
	0x70, 0xb3, 0xc9, 0xd7, 0x05, 0x2f, 0x80, 0x14, 0xfe, 0x07, 0x78, 0x8d, 0x02, 0x06, 0x09, 0x06,
	0x4c, 0xf2, 0xc0, 0x86, 0x02, 0x0b, 0xb8, 0xf1, 0xbc, 0xf5, 0x6b, 0xfb, 0xfb, 0xfb, 0x43, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x98, 0xbd, 0x7e, 0x42, 0x3e, 0x04, 0x00, 0x00,
}
